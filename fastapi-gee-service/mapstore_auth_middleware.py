"""
MapStore JWT Authentication Middleware for FastAPI
Validates JWT tokens generated by MapStore for unified authentication
"""

from fastapi import HTTPException, Request, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
import os
import logging
from typing import Optional, Dict, Any
from datetime import datetime

logger = logging.getLogger(__name__)

# JWT Configuration
JWT_SECRET = os.getenv('MAPSTORE_JWT_SECRET', 'gis-carbon-ai-jwt-secret-2024')
JWT_ISSUER = os.getenv('MAPSTORE_JWT_ISSUER', 'mapstore-gis-carbon-ai')
JWT_ALGORITHM = 'HS256'

# Security scheme
security = HTTPBearer()

class MapStoreJWTAuth:
    """MapStore JWT Authentication handler"""
    
    @staticmethod
    def validate_token(token: str) -> Optional[Dict[str, Any]]:
        """
        Validate MapStore JWT token and return payload
        """
        try:
            payload = jwt.decode(
                token,
                JWT_SECRET,
                algorithms=[JWT_ALGORITHM],
                issuer=JWT_ISSUER
            )
            
            # Check if token is expired
            exp = payload.get('exp')
            if exp and datetime.utcnow().timestamp() > exp:
                logger.warning("JWT token expired")
                return None
            
            logger.info(f"Valid JWT token for user: {payload.get('username')}")
            return payload
            
        except jwt.ExpiredSignatureError:
            logger.warning("JWT token expired")
            return None
        except jwt.InvalidTokenError as e:
            logger.warning(f"Invalid JWT token: {e}")
            return None
        except Exception as e:
            logger.error(f"Token validation error: {e}")
            return None
    
    @staticmethod
    def check_permission(payload: Dict[str, Any], service: str, action: str) -> bool:
        """
        Check if user has permission for specific service and action
        """
        permissions = payload.get('permissions', {})
        service_perms = permissions.get(service, [])
        
        # Admin users have all permissions
        roles = payload.get('roles', [])
        if 'admin' in roles:
            return True
        
        return action in service_perms

# Dependency functions
async def get_current_user(credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)) -> Optional[Dict[str, Any]]:
    """
    Get current user from JWT token (optional authentication)
    """
    if not credentials:
        return None
    
    payload = MapStoreJWTAuth.validate_token(credentials.credentials)
    if not payload:
        return None
    
    return payload

async def require_auth(credentials: HTTPAuthorizationCredentials = Depends(security)) -> Dict[str, Any]:
    """
    Require authentication (mandatory)
    """
    payload = MapStoreJWTAuth.validate_token(credentials.credentials)
    if not payload:
        raise HTTPException(
            status_code=401,
            detail="Invalid or expired token"
        )
    
    return payload

async def require_permission(service: str, action: str, user: Dict[str, Any] = Depends(require_auth)) -> Dict[str, Any]:
    """
    Require specific permission for service and action
    """
    if not MapStoreJWTAuth.check_permission(user, service, action):
        raise HTTPException(
            status_code=403,
            detail=f"Insufficient permissions for {action} on {service}"
        )
    
    return user

# Middleware for automatic token validation
class MapStoreJWTMiddleware:
    """
    Middleware to automatically validate JWT tokens for protected endpoints
    """
    
    def __init__(self, app, protected_paths: list = None):
        self.app = app
        self.protected_paths = protected_paths or [
            '/tiles/',
            '/analysis/',
            '/layers/gee',
            '/process/'
        ]
    
    async def __call__(self, scope, receive, send):
        if scope["type"] == "http":
            request = Request(scope, receive)
            path = request.url.path
            
            # Check if path requires authentication
            if any(protected_path in path for protected_path in self.protected_paths):
                token = self.extract_token(request)
                
                if not token:
                    response = HTTPException(
                        status_code=401,
                        detail="Authentication required"
                    )
                    # Handle unauthorized access
                    return
                
                payload = MapStoreJWTAuth.validate_token(token)
                if not payload:
                    response = HTTPException(
                        status_code=401,
                        detail="Invalid or expired token"
                    )
                    # Handle invalid token
                    return
                
                # Add user info to request scope
                scope['user'] = payload
        
        await self.app(scope, receive, send)
    
    def extract_token(self, request: Request) -> Optional[str]:
        """
        Extract JWT token from request headers
        """
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            return auth_header.split(" ")[1]
        return None

# Token validation endpoint
async def validate_token_endpoint(token_data: dict):
    """
    Endpoint for other services to validate MapStore JWT tokens
    """
    token = token_data.get('token')
    if not token:
        raise HTTPException(
            status_code=400,
            detail="Token required"
        )
    
    payload = MapStoreJWTAuth.validate_token(token)
    if not payload:
        raise HTTPException(
            status_code=401,
            detail="Invalid or expired token"
        )
    
    return {
        'valid': True,
        'user': {
            'id': payload.get('user_id'),
            'username': payload.get('username'),
            'roles': payload.get('roles', []),
            'permissions': payload.get('permissions', {}),
            'exp': payload.get('exp')
        }
    }

# Layer access control
class LayerAccessController:
    """
    Controls access to layers based on user permissions
    """
    
    def __init__(self):
        self.public_layers = {
            'gee': ['public_ndvi', 'public_landcover'],
            'geoserver': ['sample_geometries', 'public_boundaries']
        }
        
        self.authenticated_layers = {
            'gee': ['fcd_analysis', 'carbon_calculation', 'user_custom_analysis'],
            'geoserver': ['private_analysis', 'user_projects']
        }
    
    async def get_accessible_layers(self, layer_type: str, user: Optional[Dict[str, Any]] = None) -> list:
        """
        Get list of layers accessible to user
        """
        accessible_layers = []
        
        # Add public layers
        accessible_layers.extend(self.public_layers.get(layer_type, []))
        
        # Add authenticated layers if user is logged in
        if user:
            roles = user.get('roles', [])
            permissions = user.get('permissions', {})
            
            # Add all authenticated layers for admin users
            if 'admin' in roles:
                accessible_layers.extend(self.authenticated_layers.get(layer_type, []))
            else:
                # Add layers based on permissions
                service_perms = permissions.get('gee' if layer_type == 'gee' else 'geoserver', [])
                if 'read' in service_perms:
                    accessible_layers.extend(self.authenticated_layers.get(layer_type, []))
        
        return list(set(accessible_layers))  # Remove duplicates
    
    async def check_layer_access(self, layer_type: str, layer_name: str, user: Optional[Dict[str, Any]] = None) -> bool:
        """
        Check if user has access to specific layer
        """
        # Public layers - no authentication required
        if layer_name in self.public_layers.get(layer_type, []):
            return True
        
        # Authenticated layers - require valid user
        if layer_name in self.authenticated_layers.get(layer_type, []):
            if not user:
                return False
            
            roles = user.get('roles', [])
            permissions = user.get('permissions', {})
            
            # Admin users have access to all layers
            if 'admin' in roles:
                return True
            
            # Check service-specific permissions
            service = 'gee' if layer_type == 'gee' else 'geoserver'
            service_perms = permissions.get(service, [])
            
            return 'read' in service_perms
        
        # Default: require authentication for unknown layers
        return user is not None

# Global instance
layer_access_controller = LayerAccessController()

# Dependency for layer access checking
async def check_layer_permission(layer_type: str, layer_name: str, user: Optional[Dict[str, Any]] = Depends(get_current_user)) -> bool:
    """
    Check if user has permission to access specific layer
    """
    has_access = await layer_access_controller.check_layer_access(layer_type, layer_name, user)
    if not has_access:
        raise HTTPException(
            status_code=403,
            detail=f"Access denied to layer {layer_name} of type {layer_type}"
        )
    return True
